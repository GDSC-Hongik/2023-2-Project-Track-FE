# React로 데이터 다루기

프로그램: 프로젝트 트랙
플랫폼: 코드잇
기간: 2023년 11월 29일

**`command+shift+l`**: 같은 단어를 한 번에 수정할 수 있음. 대소문자 구분없이 단어만 같으면 커서가 생김.

**`option`**키를 누르면서 클릭을 하면 커서를 여러 군데에 추가할 수 있음. 누르면서

`**option**`키를 누른 상태에서 방향키를 누르면 줄 단위로 움직일 수 있음. `**shift**`키도 함께 누른다면 해당 방향으로 줄을 복사함.

`**F2**`키를 누르면 해당 변수나 함수를 사용한 모든 파일에서 이름을 수정할 수 있음.

- mock 데이터: 네트워크로 받아올 데이터를 흉내냄.

- `map` 함수를 이용해 많은 데이터를 받을 때 모든 요소에 접근할 수 있음.

### 정렬 기능

`sort` 메소드를 통해 값이 큰 순으로 정렬하는 방법.

```jsx
// 오름차순 기준

array.sort((a, b) => a - b);

// 반환값 < 0 : a가 b보다 앞에 있어야 한다.
// 반환값 = 0 : 순서를 바꾸지 않는다.
// 반환값 > 0 : b가 a보다 앞에 있어야 한다. // 바꾼다.
```

- state를 이용해 정렬 기준을 정하는 방법

  ⇒ state의 값으로 정렬 기준인 속성의 문자열을 넣어주고, 이를 변경시킴.

  ⇒ 정렬 함수에서 핸들러는 받은 객체의 속성으로 정렬하도록 임의로 지정함.

  ```jsx
  // ex

  const [order, serOrder] = useState("createdAt");
  const sortedItems = items.sort((a, b) => b[order] - a[order]);
  ```

- 퀴즈를 풀며 깨달은 내용

> 핸들러 함수는 정렬 기준마다 하나씩 만듦. (물론 이도 축약할 수는 있을듯.)
>
> 아이템을 전달하기 전에 먼저 정렬을 해버리는게 나은 듯. ⇒ 아이템에 접근할 때는 점 표기가 아닌 대괄호를 이용하여 접근해야함.
>
> state 값을 처음부터 요소의 프로퍼티의 이름과 맞춘다면, 굳이 이를 체크하는 함수를 또 만들 필요가 없음.

- 삭제 기능

`filter` 메소드를 통해 특정 id를 제외한 나머지 요소만 갖고 있는 배열을 반환하도록 함. → state 값을 수정한다는 생각으로 접근함.

⇒ 삭제하는 함수를 삭제 해야할 컴포넌트에 prop으로 내려줌.

### key

배열을 렌더링 할 때는 `**key**`값을 정해줘야 함 → `key`를 지정하지 않으면 동작 중에 리렌더링될 시에 의도치 않은 행동을 할 수 있음. (입력하던 칸이 이동하거나.. 등등)

⇒ `index` 말고 `**id**` 등 고유한 값으로 설정해야 함.

결과만 봐서는 어떤 동작을 통해 배열이 변화했는지 알 수 없음. (중간인덱스의 요소가 삭제된 경우, 맨마지막 요소가 삭제되고 중간인덱스의 요소의 이름이 변경되었을수도 있기 때문.)

⇒ `**key**`는 `li` 태그에 추가시켜줘야 함.

# 데이터 가져오기

목록을 가져올 때, `fetch`를 통해 가져온 정보는 `**response.json()**`을 통해 JSON으로 변환시킨 값을 저장해야 함. → **가져올 때도 함수 자체에 `await`과 `async` 잊지 말고 붙이기**

### useEffect

비동기 함수를 이용할 때, App 컴포넌트를 계속해서 렌더링 시킬 수 있는 문제가 발생 → 무한루프

딱 한번만 함수를 사용하기 위해서, 의존 배열에 아무것도 넣지 않은채 함수를 실행시킴.

```jsx
useEffect(() => {...}, []) // 두 번째 인자 배열에, 어떤 값이 변해야 렌더링할 지를 정함.
```

- dependency list: 앞에서 기억한 값과 비교하여 달라졌을 경우 콜백함수를 다시 실행함.

URL의 쿼리값을 먼저 지정하여 fetch하게 되면 정렬된 값을 얻어올 수도 있음.

### 페이지네이션

- **오프셋 기반**: 지금까지 받아온 데이터 개수(`offset`) + 앞으로 더 받아올 개수를 지정해줌.(`limit`)
  - 도중에 글 개수의 변화가 생긴다면, 문제가 발생할 수 있음. → 데이터가 많이 바뀌지 않는다면 오히려 괜찮을지도.
    (쿼리는 `&`를 통해 이어감.)
    오프셋 값에 새로 추가한 데이터의 길이를 계속 더해주며 오프셋을 초기화해줌.
  - `button`의 `disabled` 속성: `true`일 경우 버튼이 비활성화됨. ⇒ button 태그와 bool값을 AND 연산자로 이으면, 그 결과에 따라 버튼이 다르게 렌더링됨.
    ⇒ **조건부 렌더링**
- **커서 기반**: 특정 데이터를 가리키는 값. 다음 커서값을 저장하여 다음에 어떤 데이터부터 가져와야 할지 알 수 있음.

- **주의사항**

→ 비동기로 작동할때는 요소의 수정이 있을때 컴포넌트에서 반영하지 못하는 경우가 있을 수 있음. (변경 전의 state 값에 접근하는 등..)

⇒ 함수로 전달된 state는 현 시점의 값이므로 예전 값을 참조하지 않음 → 변경이 일어나지 않는 문제를 해결할 수 있음.

- **결론**: 비동기에서 state 값을 이용할 때는 콜백함수를 이용하여 변경된 state값을 참고할 수 있도록 함.

- **로딩 처리**

`disabled` 속성과 `try catch`문을 이용하여 버튼을 누르면 로딩값을 `true`로 하고, 이 상황에서는 `button`이 비활성화되도록 함.

- 에러 처리

```jsx
Error?.message; // (옵셔널 체이닝: 값이 있을 때만 참조함.)
```

response의 ok 프로퍼티를 이용하여 통신이 제대로 되었는지 확인할 수 있음 → 이에 따라 다르게 반응.

# 입력 폼

- 파일 인풋

```jsx
<input type="file" /> // 파일 형식으로 입력 받을 수 있음.
```

파일 인풋에서는 이벤트 객체의 `event.target.value`가 아니라 `**event.target.files**`를 사용함.

리액트에서는 주로 `input`의 값을 `state`로 관리함. 제어 컴포넌트 - `state`에 따라 input의 값을 동일하게 만듦.

**이벤트 핸들러** - `input`의 값이 변경될 때마다 `state`의 값을 설정해줌.

```jsx
<input value={value} onChange={handleValueChange} />
// value 값을 state로 두어, **값의 변화**가 있을 때마다 업데이트함.
// HTML 에서의 onInput처럼 작동함. 원래는 값이 등록될때마다 업데이트.
```

- `onSubmit`

`type`을 `submit`으로 지정한 버튼을 누르면 → `onSubmit` 이벤트가 발생함.

```jsx
e.preventDefault();
// 기본적으로 새로고침되는 이벤트를 막기 위해 설정함.
```

- 하나의 스테이트로 관리하기

객체로 `state`를 생성함 → 각 `input` 태그에 `name` 프로퍼티의 이름을 `state` 객체의 프로퍼티 이름으로 하여, 해당 `name`의 프로퍼티 값을 수정함.

```jsx
setValues((preValues) => {
	...preValues,
	**[name]: value**, // 모던한 프로퍼티 표기법 참고
})
```

### 제어 컴포넌트

`input`의 값을 리액트를 통해 지정함. 굳이 지정하지 않으면 비제어 컴포넌트.

동작을 제어하기 쉽다는 장점. (주로 권장됨.)

⇒ 리액트에서 사용하는 값과 실제 인풋값이 항상 일치함.

### 파일 `input`

```jsx
e.target.files; // 이벤트 객체에서 파일을 가져오는 방법.
```

여러 파일을 담고 있을 수 있으므로 인덱스로 접근함.

파일 이름을 받아야하는데 자바스크립트에서는 이름값을 바꿀 수 없음. (웹 브라우저는 보안을 위해 경로를 숨겨줌.)

⇒ 반드시 비제어 `input`으로 관리해야 함.

### useRef

원하는 시점에 실제 DOM 노드에 접근하고 싶을 때 사용할 수 있음.

돔 노드는 렌더링이 끝나야 생김. 컴포넌트가 렌더링되어야 함 → `Ref.current`값을 확인하고 이용해야 함.

파일의 `value`값은 사용자만 직접 바꿀 수 있음.

`value`의 값은 빈 문자열`””`로 하여 초기화하고, 사진은 이벤트 핸들러에 `null` 값을 전달하여 초기화함.

`**ObjectURL**`을 이용하여 파일들의 주소를 만들어낼 수 있음.

```jsx
URL.createObjectURL($value); // 해당 파일의 주소를 문자열로 반환해줌.
```

컴포넌트에서 외부의 상태를 바꾸는 것 - **사이드 이펙트** ⇒ `useEffect`를 활용함.

예시: `페이지 정보 변경`, `네트워크 요청`, `데이터 저장`, `타이머` 등 ⇒ 동기화에 쓰면 유용함.

→ 메모리를 할당하기만 하게 됨. **사이드 이펙트를 정리할 필요가 있음.**

```jsx
return () => {
  // state를 초기화하는 코드 작성.
  URL.revokeObjectURL($value); // 메모리 할당을 해제 해줌.
};
// useEffect 함수에서 리턴값으로 함수를 주면, 제거하는 데 사용할 수 있음.
// 의존 배열에서 값이 변경되면, 리턴값인 "**정리함수**"를 실행함.
```

---

# 데이터 보내기

- `**FormData**` → API 연동

```jsx
const formdata = new FormData();
```

전달되는 데이터 형식: `multipart/form-data`

기존에 입력받던 값들을 서버와 통신하기 위해 형식을 만드는 것.

```jsx
fetch("$url", {
  method: "POST",
  body: formdata, // formdata.append('name', 'value')를 통해 추가한 값들을 보냄.
});
```

`fetch` 함수를 이용하므로 비동기화 해야함을 잊지 말기.

기본적으로 버튼을 여러번 눌러서 생기는 오류가 있을 수 있으므로 에러 처리하는 걸 잊지 말기.

그러나.. 데이터를 바로 반영하지 않는다는 문제가 발생함.

⇒ (1) 정상적으로 제출되었을 때, (2) 리렌더링 할 수 있는 작업을 추가하면 됨.

### 글 수정하기

수정버튼을 눌렀을 때, 글이 수정 아이템으로 바뀌면서

**(1) 입력했을 때 사용한 폼이 나타나야 하고, (2) 해당 칸에 원래 내용들이 채워져 있어야 함.**

→ 그러나 사진이 미리보기가 안됨. 사진이 미리보기가 되도록 `prop`을 추가시켜줘야 함.

`FormData`를 통해 수정할 데이터를 `**PUT**` 메소드로 보내면 해당 값을 수정함. → 어떤 ID의 값을 수정할 지 알고, 이를 전달해야 함.

→ 어떻게 해당 위치의 값을 알아내고 수정하는가?

(1) 특정 아이디에 해당하는 값의 **인덱스**를 알아내고, (2) `slice` 문법을 통해 해당 위치 앞뒤로 잘라내어 `spread`하고, (3) 수정한 데이터를 삽입하여 리스트를 반환함.

기본적으로 현 상태에 관한 내용, 작업이 성공했는지 여부 등을 `prop`으로 전달하는 경우가 많음.

### 글 삭제하기

`**DELETE**` 메소드는 body값이 없어도 실행됨.

⇒ 모든 작업에는 `response`가 `**ok**`가 아닐때를 대비하여 예외처리를 해주어야 함.

## 리액트 Hook

- **`use`**로 시작하는 함수들을 총칭하는 말.

`**useState**`: 리액트가 관리하는 `State`에 연결해서 변수처럼 값을 사용함.

`**useEffect**`: 내 콜백함수를 리액트에 연결해서 렌더링 후에 함수 실행함.

`**useRef**`: 리액트가 관리하는 `Ref` 객체에 연결해서 `current`값을 사용함.

- 리액트 Hook의 규칙

1. **리액트 컴포넌트 함수**나 **커스텀 Hook 함수** 내에서만 실행되어야 함.
2. 함수의 최상위에서 실행되어야 함. (반복문이나 조건문 안에서 쓰이면 안됨.) → 모든 렌더링 마다 같은 순서로 실행되어야 함.(실행하는 순서대로 연동됨.)

### custom hook

반복되는 코드들을 추상화하여 나만의 Hook을 만들 수 있음 ⇒ 커스텀 훅

- 커스텀 훅 규칙: 커스텀 훅이라는 걸 다른 개발자가 알 수 있도록 `use`를 앞에 사용해야 함.

→ **비동기 함수의 예외처리** 등의 코드에서 사용할 수 있음.

- 기존 함수 내에 따로 존재하던 예외처리 코드를 하나로 묶어서 훅을 만들어서 사용함.
- 기존 함수를 인자로 받아 정상적으로 실행될 수 있을 때 해당 함수를 실행함.

⇒ 리스트로 반환하여, 기존의 `useState`처럼 비구조화 할당을 받을 수 있도록 함.

⇒ 코드도 깔끔하고, 관리하기에도 용이함.

### useCallback

함수를 dependency list에 추가하면 무한 루프가 발생할 수도(함수가 매번 새로 만들어지는 경우.)

→ `**react-hooks/exhaustive-deps**` 경고 메시지가 발생.

⇒ `**useCallback**` 함수를 이용하면 함수를 기억해두었다가 재사용할 수 있음.

```jsx
const $name = useCallback($function, [$dependency - list]);
```

의존리스트에 리액트 Hook 함수는 괜찮지만, 개인이 따로 만든 함수의 경우는 넣어줘야 함. ⇒ 해당 함수도 무한 루프가 발생할 수 있다는 걸 또 고려 해야 함.

→ 변하는 함수와 변하지 않는 함수가 무엇인지를 고려하여 의존리스트를 채우고, `useCallback`으로 감싸고를 반복해야 함. ⇒ **prop이나 state와 관련된 값은 빠짐없이 디펜던시에 추가하기를 권장함.**

---

# Context

프로젝트 전체적으로 사용하는 데이터 → 상위 컴포넌트에서 하위 컴포넌트로 계속해서 prop을 내려줘야 하는 문제가 발생함. (Prop Drilling)

**`<Context.Provider />`**를 통해 감싸준 컴포넌트 안에서는 Context를 사용할 수 있음.

```jsx
const $contextName = createContext();

**... App.js**

<$contextName.Provider value={value}> // 전달할 값을 prop으로 전달함.

**... Context를 사용할 파일**

const $name = useContext($contextName);
```

- context와 state를 함께 사용하기

```html
<select>
  <!-- option을 주고 값을 선택할 수 있도록 함.-->
  <option value="ko">한국어</option>
  <option value="en">영어</option>
</select>
```

Context와 Context의 value값을 함께 관리할 수 있도록 코드를 모아놓을 필요가 있음. → custom hook을 함께 활용하여 정리할 수 있음.

⇒ **다른 곳에서는 state값을 직접 참고하지 못하고 반드시 Context를 통해서만 사용 가능함. 나중에 Context를 옮길 때 더 용이함.**
