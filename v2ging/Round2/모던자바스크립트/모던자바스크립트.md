# 모던 자바스크립트

### js의 데이터 타입

- number
- string
- boolean
- undefined
- null
- object
- symbol
- bigint: 아주 큰 정수를 표현하기 위해 등장한 데이터 타입
  - 자바스크립트의 숫자형 (number type) 값에는 9000조 정도의 정수 표현의 한계가 존재한다. 이보다 더 큰 정수를 표현할 때 사용한다.
  - 일반 정수 마지막에 알파벳 n을 붙이거나 BigInt 라는 함수를 사용하면 된다.
  - 소수 표현에는 사용할 수 없다.
  - 같은 타입끼리만 연산할 수 있고, 서로 다른 타입끼리의 연산은 명시적으로 타입 변환을 해야 한다.

### Symbol

코드 내 유일한 값을 가진 변수 이름을 만들 때 사용한다.

```jsx
const user = Symbol();
// 심볼이라는 함수를 통해 심볼 값을 만들어 낼 수 있다.

const user = Symbol("this is user");
// 괄호 안에 심볼에 대한 설명을 붙일 수 있다.
// 심볼 값을 담게 된 user라는 이름의 변수는 다른 어떤 값과 비교해도 true가 될 수 없는 고유한 변수가 된다.
// 똑같은 설명을 붙인 심볼을 만들더라도 두 값을 비교하면 false가 반환된다.
```

### typeof

데이터 타입을 알아볼 때 사용하는 연산자

```jsx
typeof null;
// 문자열 object 리턴됨
// -> js 처음 구현될 때 특별한 문법 설계 때문

typeof function () {};
// function 리턴
// 함수는 객체로 취급됨!
```

### Falsy / Truthy

- Falsy
  - false, null, undefined, NaN, 0, ""(빈문자열)
  - Boolean() 함수 → false 리턴
- Truthy
  - 나머지, 빈객체와 빈배열!
  - Boolean() 함수 → true 리턴

### AND와 OR

- and 연산자
  - 왼쪽 값이 truthy하면 오른쪽 값 리턴
  - 왼쪽 값이 falsy하면 왼쪽 값 리턴
  - or 연산자보다 우선순위가 더 높다
- or 연산자
  - 왼쪽 값이 truthy하면 왼쪽 값 리턴
  - 왼쪽 값이 flasy하면 오른쪽 값 리턴

### null 병합 연산자 ??

?? 물음표 두 개를 사용해서 null 또는 indefined 값을 가려내는 연산자

- 연산자 왼편의 값이 null 이나 undefined라면, 연산자 오른편의 값이 리턴
- 연산자 왼편의 값이 null 이나 undefined가 아니라면, 연산자 왼편의 값이 리턴

### var

- 이전 변수 할당
- 호이스팅 일어남! (변수 사용보다 변수 선언이 나중에 되어도 됨) - undefined
- 중복 선언 가능
- 유효범위, 스코프 -> 함수 단위
  - 조건문이나 반복문 안에서 새로운 변수를 만들게 되더라도 모두 전역 변수로 평가된다. → 함수 스코프 (function scope)

### let / const

- 현재 변수 할당
- 값의 재할당
  - 필요O → let
  - 필요X -> const
- 호이스팅 일어나지 않음!
- 중복 선언 불가능
- 유효범위, 스코프 -> 중괄호 단위
  - 조건문, 반복문, 함수 내에서만 사용가능한 새로운 변수 만들 수 있음 → 블록 스코프 (block scope)

### 함수를 만드는 방법

- 함수 선언식 - 호이스팅 가능: 함수를 선언하기 이전에 함수를 호출해도 정상적으로 동작
  - 함수 scope
  ```jsx
  function sayHi() {
    console.log("Hi!");
  }
  ```
- 함수 표현식(= 함수를 값으로 할당) - 호이스팅 불가능: 반드시 변수가 선언된 이후에 함수를 호출해야 정상적으로 동작
  - 할당된 변수의 특성에 따라 스코프가 결정
    - var: 함수스코프
    - let과 const: 블록스코프
    ```jsx
    const sayHi = function () {
      console.log("Hi!");
    };
    ```
- 기명 함수 표현식(Named Function Expression)
  - 함수 표현식으로 함수가 할당된 변수에는 자동으로 name이라는 프로퍼티를 가지게 된다.
    - 이름이 없는 함수를 변수에 할당할 때: 변수의 name 프로퍼티 = 변수 이름 그 자체 문자열
    - 이름이 있는 함수를 변수에 할당할 때: 변수의 name 프로퍼티 = 함수 이름 문자열
  - 함수 이름은 함수 내부에서 함수 자체를 가리킬 때 사용할 수 있고(재귀적인 구조) 외부에서 함수를 호출할 때 사용할 수는 없다.
- 즉시 실행 함수 (Immediately Invoked Function Expression)
  ```jsx
  (function () {
    console.log("Hi!");
  })();
  ```
  - 함수 선언 부분을 소괄호를 감싼 다음 바로 뒤에 함수를 실행하는 소괄호를 한 번 더 붙여준다.
  - 프로그램 초기화 시, 재사용이 필요 없는 일회성 동작을 구성할 때 활용한다.
  - 일반 함수처럼 파라미터를 작성하고, 함수 호출 시 아규먼트를 전달할 수도 있다.
  - 주의) 함수에 이름을 지어주더라도 외부에서 재사용할 수 없다.
    - 주로 익명함수 이용 but 재귀적인 구조를 만들고자 할 땐 이름이 필요할 수 있다.

자바스크립트의 함수

1. 함수 표현식으로 함수 만들기
2. 객체의 프로퍼티로 함수를 선언해서 메소드를 만들기
3. 배열의 요소로 만들기
   함수의 구체적인 타입은 객체이다.

### 콜백 함수 (Callback Function)

다른 함수의 파라미터에 전달된 함수

- 고차함수: 함수가 함수를 리턴하는 함수 -> 변수의 호출된 값을 할당해서 활용, 이중괄호 사용
- 파라미터 parameter
  - 함수 선언 시 소괄호 안에 작성되는 것, 함수 내부의 동작 부분에서 변수처럼 사용할 수 있다.
  - 할당 연산자로 기본값 설정 가능 - 함수 호출 시 아규먼트 전달하지 않으면 기본값을 가지고 동작하게 된다.
- 아규먼트 argument
  - 함수 호출 시 파라미터로 전달하는 값
  - 함수 호출 시 undefined 값 전달해서 파라미터의 기본값을 사용할 수 있다.
  - 아규먼트 개수에 유연한 함수
    - 함수 내부에서 자동으로 만들어지는 arguments(유사배열)라는 특별한 객체 사용하기
    - 따라서, 파라미터의 이름을 arguments로 짓거나 함수 내부에서 arguments라는 이름의 변수나 함수를 만드는 것을 피해야 한다.
- Rest Parameter
  - 파라미터 앞에 ... 마침표 세 개 붙임
  - 배열 형태이므로 배열의 메소드 사용 가능
  - 일반 파라미터와 함께 사용할 때는 가장 마지막에 나와야 한다.
- arrow function
  - 이름이 없는 익명 함수
    ```jsx
    const abc = () => {};
    // 파라미터 한 개인 경우: 소괄호 생략 가능
    ```
    - 함수 내부 동작 부분이 return 한줄이라면, 중괄호와 함께 생략 가능
    - 함수 내부 동작 부분이 return문 한줄이지만 return 값이 객체인 경우, 중괄호와 return 키워드를 생략하면 오류가 발생하므로 중괄호 바깥에 소괄호로 한번 감싸기
    - 일반 함수와의 차이점
      - argument 객체가 없음!!
      - this를 다루는 방법: arrow function이 선언되기 직전에 그때 유효한 this 값과 똑같은 값을 가지고 작동하게 된다.

### this

메소드 호출한 객체를 가리키는 키워드

- 함수 내부에서 주로 사용, 특히 객체의 메소드 생성시 주로 사용된다.
- 메소드가 호출될 때 어떤 객체가 함수를 호출했는지에 따라 값이 달라진다.
  - 그냥 this, 함수 선언하고 this 호출 시 window 호출됨

### 자바스크립트의 문법과 표현

- 문장(statements): 어떤 동작이 일어나도록 작성된 최소한의 코드 덩어리
- 표현식(expressions): 길이와는 상관없이 결과적으로 하나의 값이 되는 모든 코드
  - 표현식은 보통 문장의 일부로 쓰이지만, 그 자체로 문장일 수도 있다.
    - 예시) 할당식, 함수 호출
  - 표현식인 문장 vs 표현식이 아닌 문장
    - 조건문, 반복문 -> 값으로 평가되지 않고 오로지 문장으로만 평가된다.

### 삼항 연산자(Ternary operator)

```jsx
조건 ? truthy 할 때 표현식 : falsy 할 때 표현식
// 조건연산자는 표현식이기 때문에 조건에 따라 변수를 선언하거나 반복문을 실행할 수는 없다.
// -> 모든 if문을 대체할 수는 없다.
```

### spread

여러개의 값을 하나로 묶은 배열을 각각의 개별 값으로(여러 개의 값으로) 펼치는 개념

- 배열 앞에 ... 마침표 세개 붙여줌
- 배열을 펼쳐 객체로 만들면 0번부터 시작하는 배열의 인덱스가 프로퍼티 네임이 되어 객체가 만들어진다.
- 배열을 spread 하면 새로운 배열을 만들거나 함수의 아규먼트로 쓸 수 있지만, 객체로는 새로운 배열을 만들거나 함수의 아규먼트로 사용할 수 없다. 그렇기 때문에 객체를 spread 할 때는 반드시 객체를 표현하는 중괄호 안에서 활용해야 한다.
- 함수 호출시에도 사용 가능

### 모던한 프로퍼티 사용법

- 변수에 할당된 값을 활용하여 프로퍼티를 만들 때, 활용할 변수의 이름과 프로퍼티 네임이 같다면
  - title: title -> title 이런 식으로 하나만 써도 가능하다.
- 객체 내부에서 메소드를 선언할 때, :과 function 키워드 생략 가능
  - getFullName: function () {} -> getFullName() {}
- 계산된 속성명(computed property name): 프로퍼티 네임을 표현식으로 나타내는 방법
  - const user = { [표현식]: 값, };
  - 대괄호로 감싸서 표현식을 작성하는 방식은 변수에 담긴 값을 사용하거나 함수의 리턴값을 사용할 수도 있다.

### 옵셔널 체이닝 (Optional Chaining)

중첩된 객체를 다룰 때 에러를 방지하기 위한 방식 중 하나

- 옵셔널 체이닝 연산자(?.)
  - 왼편의 프로퍼티 값이 undefined 또는 null 이 아니라면 그 다음 프로퍼티 값을 리턴한다.
  - 그렇지 않은 경우에는 undefined를 반환한다.

### Destructuring(구조분해)

배열과 객체에 각각 적용되는 방식이 다르다.

- 배열
  ```jsx
  const rank = [유나, 류진, 별이, 달이];
  const [mackbook, ipad, airpods, coupon] = rank;
  ```
  - 할당연산자 왼편에 변수의 이름이 배열의 형태로 선언되어 있고 rank 배열 자체를 할당함 -> 배열의 요소들이 순서대로 할당 된다.
  - 배열의 형식이 아니거나 아무것도 할당하지 않으면 오류가 난다.
  - 선언된 배열의 개수와 변수의 개수가 같을 필요가 없다.
    - 순서가 중요!
  - 마지막 변수에 마침표 세개 붙여주면 남은 나머지 요소를 마지막 변수의 배열에 할당하는 것이 가능함
  - 할당하는 배열의 길이가 선언된 변수의 길이가 작은 경우: undefined 값 할당된다.
  - 기본값을 할당 할 수 있다.
  - 변수에 할당된 값 교환할 때도 사용 가능하다.
    - [mackbook, ipad] = [ipad, macbook];
- 객체
  - 점 표기법을 사용하지 않고 프로퍼티 네임 자체를 변수처럼 사용하고자 할 때 사용
    - const {title, price} = macbook;
  - 프로퍼티 네임을 통해 분해가 되어 똑같은 프로퍼티 네임이 있으면 그 변수 이름에 값이 할당된다.
  - 배열의 구조분해와 유사하게 작동한다.
  - 프로퍼티 네임과 다른 다른 이름을 사용하고 싶으면 또는 프로퍼티 네임 중 변수 이름으로 사용할 수 없는 경우 (= ""로 묶여 중간에 하이픈이 포함된 경우) 새로운 이름으로 변수를 선언한다.
    - title: product 콜론 이용
    - [title]: product 대괄호 이용해 computed 프로퍼티 네임을 활용할 수도 있다.

### 중첩 객체 구조 분해 (Nested Object Destructing)

중첩된 객체: {내부} → 분해 가능!

### 에러와 에러 객체

자바스크립트에서는 에러가 발생한 순간 코드가 멈춰버린다. -> 에러 다루기 필요!

- 에러 발생 시 자동으로 그 에러에 대한 정보가 담긴 에러 객체를 생성한다.
- 에러 객체는 name, message 프로퍼티를 가진다.
- 자주보는 에러: 레퍼런스 에러, 타입 에러, Syntax error
- 의도적으로 만드는 에러 객체
  - const error = new TypeError('타입 에러 발생!');
  - throw error; // 에러 실행하기

### 예외처리 Exception Handling

- try catch문
  - 실행이 가능한 코드에서 실행된다. = syntax error 시 실행X
    ```jsx
    try {
      // 동작 시킬 코드
    } catch (error) {
      // error 발생 시 동작 시킬 코드
    } finally {
      // 에러 여부와 상관 없이 항상 실행할 코드
      // finally 문에서도 에러처리가 필요한 경우 try...catch문 중첩해서 활용
    }
    console.error(error); // 우리에게 익숙한 에러코드처럼 출력된다.
    ```

### forEach

리턴 값이 없기 때문에 변수에 담으면 항상 undefined가 출력된다. 단순한 반복작업시 사용한다.

```jsx
members.forEach(function (member) {
console.log(`${member}님이 입장`);
});

- arrow function
members.forEach((member) => {
console.log(`${member}님이 입장`);
});

// 콜백함수의 첫번째 파라미터: 메소드를 호출할 때 아규먼트로 콜백함수를 작성해주게 되면 콜백함수의 첫번째 파라미터로 배열의 요소를 순서대로 하나씩 전달하면서 매번 이 함수를 실행하는 원리로 실행된다.
// 콜백함수의 두번째 파라미터: 요소의 index 관리
// 콜백함수의 세번째 파라미터: 반복 중인 배열 자체가 전달된다. 배열값 자체에 forEach문 사용시 주로 사용된다.
```

### map

forEach와 비슷하게 동작하지만 메소드의 호출 결과로(리턴 값으로) 새로운 배열을 리턴한다. 반복 잡업을 통해 새로운 배열이 필요한 경우에 사용한다.

두 메소드의 최대 반복 횟수 = 메소드를 처음 호출할 때 그 당시의 배열의 요소 개수
반복 중에 배열의 길이가 줄어들면 반복 횟수도 함께 줄어든다.

### filter

- 조건에 맞는 요소들만 추려내기
- 리턴문으로 값을 전달하는 것이 아니라 true/false로 평가되는 조건식을 리턴한다.
- 리턴값이 항상 배열이다.
- spread 구문을 사용해 배열을 벗겨낼 수 있다.
- 조건을 만족하는 모든 요소를 찾는다.

### find

- 리턴값이 값이다.
- spread 구문 사용하지 않아도 배열을 벗겨낼 수 있다.
- 조건을 만족하는 하나의 요소를 찾는다.
- 존재하지 않는 값을 찾으려고 하면 undefined가 출력된다.

### some

- 조건을 만족하는 요소가 1개 이상 있는지 - true/false
- 반복: true를 찾으면 반복 종료

### every

- 모든 요소가 조건을 만족하는지, 조건을 만족하지 않는 요소가 1개 이상 있는지 - true/false
- 반복: 조건을 만족하지 않는 요소를 찾으면 종료

### reduce

```jsx
const numbers = [1, 2, 3, 4];
numbers.reduce((acc, el, i, arr)) => {
return	nextAccValue;
}, initialAccValue);

// 첫번째 파라미터: 누산기(Accumulator)
// 두번째: 배열의 요소, 세번째: 배열의 인덱스, 네번째: 호출한 배열
```

- acc: 매번 콜백함수가 반복해서 동작할 때, 직전에 동작한 콜백함수가 리턴한 값을 전달받는다.
- 첫번째 콜백 함수가 실행될 때 acc 값을 reduce 메소드의 두 번째 아규먼트로 전달한다. (선택사항 - 전달하지 않는다면 배열의 0번 인덱스의 요소 값이 첫 번째 실행되는 콜백함수의 acc로 전달된다.)

### sort

원본 배열의 요소 정렬

아무런 아규먼트도 전달하지 않을 때: 유니코드에 정의되니 문자열 순서에 따라 정렬된다.

```jsx
// 오름차순 정렬
numbers.sort((a, b) => a - b);
// 내림차순 정렬
numbers.sort((a, b) => b - a);
```

### reverse

원본 배열의 요소를 뒤집어 버림

별도의 파라미터가 존재하지 않는다. 단순히 배열의 순서가 뒤집힌다.

### Map

이름이 있는 데이터를 저장한다는 점에서 객체와 비슷하다. 하지만 Map은 메소드를 통해서 값을 추가하거나 접근할 수 있다

```jsx
// Map 생성
const codeit = new Map();

map.set(key, value): key를 이용해 value를 추가하는 메소드.
map.get(key): key에 해당하는 값을 얻는 메소드. key가 존재하지 않으면 undefined를 반환.
map.has(key): key가 존재하면 true, 존재하지 않으면 false를 반환하는 메소드.
map.delete(key): key에 해당하는 값을 삭제하는 메소드.
map.clear(): Map 안의 모든 요소를 제거하는 메소드.
map.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)
```

### set

여러 개의 값을 순서대로 저장한다는 점에서 배열과 비슷하다. 그러나 배열의 메소드는 활용할 수 없고 set만의 메소드를 통해서 값을 다룬다.

```jsx
// Set 생성
const members = new Set();
set.add(value): 값을 추가하는 메소드. (메소드를 호출한 자리에는 추가된 값을 가진 Set 자신을 반환.)
set.has(value): Set 안에 값이 존재하면 true, 아니면 false를 반환하는 메소드.
set.delete(value): 값을 제거하는 메소드. (메소드를 호출한 자리에는 셋 내에 값이 있어서 제거에 성공하면 true, 아니면 false를 반환.)
set.clear(): Set 안의 모든 요소를 제거하는 메소드.
set.size: 요소의 개수를 반환하는 프로퍼티. (메소드가 아닌 점 주의! 배열의 length 프로퍼티와 같은 역할)

```

- 개별 값에 바로 접근하는 방법이 없다!
- 중복되는 값을 허용하지 않는다.
- 처음 생성할 때 아규먼트로 배열을 전달할 수도 있다.

### 자바스크립트 모듈

모듈화란? 공통된 기능이나 특별한 목적에 따라 각각의 파일로 구분하는 것

모듈이란? 공통된 기능이나 특별한 목적에 따라 각각의 파일로 구분한 파일

각각의 파일로 나눠 관리하면 좋은 점

1. 코드를 좀 더 효율적으로 관리할 수 있다.
2. 비슷한 기능이 필요할 때 다른 프로그램에서 재사용 할 수도 있다는 장점이 있다.

모듈파일의 조건

- 모듈 스코프: 모듈이 가지는 독립적인 scope
- 모듈의 변수와 함수는 파일 안에서만 사용 가능해야 한다.
  - js file의 모듈 스코프를 만들어 주려면 html 파일에서 js를 불러올 때 타입 속성을 모듈로 지정해주어야 한다.
  - <scirpt type = "module" src ="asdf.js"/>

모듈 문법

- 외부로 내보내고 싶은 변수나 함수는 선언문 앞에 export 키워드를 붙여준다. - Named export 방식
- export된 값이나 함수를 다른 파일에서 불러오는 과정이 필요하다.
- import (사용할 변수, 함수} from '변수, 함수 가져올 파일';

이름 바꾸기

- 이름이 중복되지 않게 import 하는 함수나 변수의 이름을 바꾸기 as 키워드 사용
  - title as printerTitle

export 한 모든 대상 한 번에 import 하기

- import \* as 새로운이름 from '파일 위치';
- 사용시 객체 형식으로 사용

한 번에 export하기

- export {title as printerTitle, print};

Default export 방식

- export default 하나의 대상;
- 모듈 내에서 딱 한 번만 사용할 수 있다.
- import 시에 default as 이름; 으로 사용해야 한다.
- default as를 제외한 이름 부분만 중괄호 밖으로 빼서 사용할 수도 있다. - Default와 Named 구별 가능
  - export default { title, print (여러개) };
    // {title:title, print:print}
    여러 대상을 객체 값으로 모아 내보낼 수 있다. = 객체 형태로 사용할 수 있다. - 점 표기법, 모듈파일을 불러온 입장에서 각 대상의 이름을 변경할 수 없음
  - export {moduel1, mo2, mo2};
    여러개의 모듈을 모아 다시 하나의 모듈 파일로 만들어 파일관리를 할 수도 있다.
